자바에서 인퍼테이스는 객체의 사용 방법을 정의한 타입이다.(객체 사용 설명서)
인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다.
인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다.
개발코드에서 인터페이스 메소드 호출 -> 인터페이스는 객체의 메소드를 호출 -> 리턴값
떄문에 개발코드는 객체의 내부구조를 알 필요가 없고 인터페이스의 메소드만 알고있으면 된다.
개발코드가 직접 객체의 메소드를 호출하면 간단하지만 개발 코드를 수정하지 않고 사용하는 객체를 변경할수 있도록 하기위해 인터페이스가 존재
인터페이스는 하나의 객체가 아니라 여러객체들과 사용이 가능하므로 어떤 객체를 사용하느냐에 따라서 실행내용과 리턴값이 다를 수 있다.
따라서 개발코드 측면에서는 코드 변경 없이 실행 내용과 리턴값을 다양화할 수 있다!!

인터페이스는 상수와 메소드만을 구성 멤버로 가진다.
인터페이스는 객체로 생성할 수 없기 때문에 생성자를 가질 수 없다.
추상메소드, 디폴트메소드, 정적 메소드만 선언 가능

상수는 인터페이스에 고정된 값으로 런타임 시에 데이터를 바꿀 수 없다. 반드시 초기값 대입!
인터페이스는 데이터를 저장할 수 없기 때문에 생략하더라도 public static fianl이 컴파일 과정에서 붙음
상수명은 대문자로 작성하되 다른단어로 구성되어있을 경우 _(언더바) 사용

추상메소드는 호출할 때 어떤 매개값이 필요하고, 리턴타입이 무엇인지만 알려준다. 실제 실행부는 (구현)객체가 가지고있다.
인터페이스에 선언된 추상메소드는 모두 public abstract의 특성을 갖는다. 생략해도 자동적으로 컴파일 과정에서 붙음
public abstract 리턴타입 메소드명(매개변수);  -> 중괄호{}를 붙히지 않는 추상메소드

디폴트메소드는 인터페이스에 선언되지만 (구현)객체가 가지고 있는 인스턴스 메소드라 생각해야함.
따라서 구현 객체가 있어야 사용할 수 있다.
디폴트 메소드는 인터페이스의 모든 구현 객체가 가지고 있는 기본 메소드라 생각하면된다.
만약 구현 객체에서 디폴트 메소드 내용이 맞지 않아 수정을 할 수도 있으며 이때는 디폴트메소드재정의(오버라이딩)을 통해 가능하다.
public default 리턴타입 메소드명(매개변수){}


정적메소드는 디폴트메소드와 달리 객체가 없어도 인터페이스만으로 호출이 가능하다.
public static 라턴타입 메소드명(매개변수){}

개발 코드가 인터페이스 메소드를 호출하면 인퍼페이스는 객체의 메소드를 호출한다.
객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름,매개 타입, 리턴타입을 가진 실체 메소드를 가지고있어야 한다.
이러한 객체를 인터페이스의 구현객체라고 하며 구현 객체를 생성하는 클래스를 구현클래스라고 한다.

구현클래스는 보통클래스와 동일하며 인터페이스 타입으로 사용할 수 있음을 알려주기 위해
선언부에 implements 키워드를 추가하고 인터페이스명을 명시해야 하고 인터페이스에 선언된 추상 메소드의 실체 메소드를 선언해야 한다.

구현클래스가 작성되면 new 연산자로 객체를 생성할 수 있다!
문제는 어떤 타입의 변수에 대입하느냐?
인터페이스명 인터페이스변수;
인터페이스변수 = 인터페이스구현객체;
또는
인터페이스 인터페이스변수 = 인터페이스구현객체;

익명 구현객체
구현 클래스를 만들어 사용하는 것이 일반적이고, 클래스를 재사용할수있기 때문에 편리하지만,
일회성의 구현객체를 만들기 위해 소스파일을 만들고 클래스를 선언하는 것은 비효율적이다.
자바는 소스파일을 만들지 않고도 구현객체를 만들 수 있는 방법을 제공하는데 이것이 익명구현객체이다.
자바는 UI프로그래밍에서 이벤트를 처리하기위해, 임시 작업 스레드를 만들기 위해 익명구현객체를 활용한다.
람다식은 인터페이스의 익명구현객체를 만들기 때문에 익명구현객체 코드패턴을 잘 봐야함!(맨 뒤 세미콜론 반드시 붙여야함)
인터페이스 변수 = new 인터페이스(){
 인터페이스에 선언된 추상메소드의 실체 메소드선언
};
new 연산자 뒤에 클래스 이름은 없다. 인터페이스(){}는 인터페이스를 구현해서 클래스를 선언하라는 뜻.
new 연산자는 이렇게 선언된 클래스를 객체로 생성.
{}안에는 실체메소드들을 작성할수 있으며 추가로 필드와 메소드를 선언할 수 있지만
익명객체안에서만 사용할 수 있고 인터페이스 변수로 접근할 수 없다.
모든객체는 클래스로 부터 생성되는데 익명 구현 객체도 예외는 아님 컴파일러에 의해 자동으로(클래스명$1,2,...)클래스 파일이 만들어짐

다중인터페이스
인터페이스A와 인터페이스B가 객체의 메소드를 호출할 수 있으려면 객체는 이 두 인터페이스를 모두 구현해야한다.
public class 구현클래스명 implements 인터페이스A, 인터페이스B{
 인터페이스A, 인터페이스B 추상 메소드의 실체 메소드 선언
}

개발코드에서 인터페이스는 클래스의 필드, 클래스의 생성자, 메소드의 매개변수, 메소드의 생성자, 메소드의 로컬 변수로 선언될 수 있다.

타입변환과 다형성
다형성은 하나의 타입에 대입되는 객체에 따라서 실행 결과가 다양한 형태로 나오는 성질.
상속은 같은 종류의 하위 클래스를 만드는 기술이고, 인터페이스는 사용방법이 동일한 클래스를 만드는 기술이라는 개념적 차이가 있다.
프로그램을 개발할 때 인터페이스를 사용해서 메소드를 호출하도록 코딩을 했다면,
프로그램 소스코드는 변함이 없는데 구현객체를 교체함으로써 프로그램의 실행 결과는 다양해진다. 이것이 인터페이스의 다형성이다.

구현 객체가 인터페이스 타입으로 변환되는 것은 자동타입변환(Promotion)에 해당된다.
인터페이스 인터페이스변수 = 구현객체; //구현객체가 변수로 자동 타입변환
인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었다면 자식객체 역시 인터페이스타입으로 자동타입변환시킬 수 있다.
자동타입변환을 이용하면 필드의 다형성과 매개변수의 다형성을 구현할 수있다.
필드의 다형성
상속에서는 자식클래스로, 인터페이스에선 구현클래스로 교체 가능한 객체
매개변수의 다형성
매개값을 다양화하기 위해 상속에서는 매개변수를 부모타입으로 선언하고 호출할때는 자식객체로 대입했지만
인터페이스에서는 매개변수를 인터페이스 타입으로 선언하고 호출할때는 구현객체를 대입

강제타입변환
구현객체가 인터페이스 타입으로 자동변환하면 인터페이스에 선언된 메소드만 사용가능하는 제약이 생긴다.
구현클래스에 선언된 필드와 메소드를 사용해야 할 경우 강제타입변환을 해서 구현클래스의 필드와 메소드를 사용한다.
구현클래스 변수 = (구현클래스) 인터페이스변수;
객체타입확인(instanceof)
강제타입변환은 구현객체가 인터페이스 타입으로 변환되어 있는 상태에서 가능하다.
그러나 어떤 구현 객체가 변환되어 있는지 알 수 없는 상태에서 무작정 변환할 경우 ClassCastException 이 발생할 수 있음.
어떤 구현 객체가 인터페이스 타입으로 변환되어있는지 확인 할 경우 instanceof 연산자를 사용

인터페이스상속
인터페이스도 다른 인터페이스를 상속할 수 있다. 인터페이스는 클래스와 달리 다중상속을 허용한다.
public interface 하위인터페이스 extends 상위인터페이스1, 상위인터페이스2{}
하위인터페이스를 구현하는 클래스는 하위인터페이스의 메소드뿐만 아니라 상위 인터페이스의 모든 추상메소드에 대한 실체메소드가 있어야한다.
다음과 같이 하위 및 상위 인터페이스 타입으로 변환가능
하위인터페이스 변수 = new 구현클래스();
상위인터페이스 변수 = new 구현클래스();
하위 인터페이스로 타입변환이 되면 상,하위 인터페이스에 선언된 모든 메소드를 사용할 수 있으나,
상위 인터페이스로 타입변환이 되면 상위 인터페이스에 선언된 메소드만 사용 가능하다.

디폴트메소드는 인터페이스에 선언된 인스턴스메소드이기 때문에 구현객체가있어야 사용할 수 있다.
인터페이스에서 디폴트메소드를 허용한 이유는 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서다.
기존 인터페이스의 이름과 추상메소드의 변경없이 디폴트 메소드만 추가할 수 있기 때문에 이전에 개발한 구현클래스를 그대로 사용할수 있으면서
새롭게 개발하는 클래스는 디폴트 메소드를 활용할 수 있다. 필요에따라서는 재정의해서 활용할수있음.

디폴트메소드가 있는 인터페이스 상속
부모 인터페이스에 디폴트메소드가 정의되어있을 경우, 자식인터페이스에서 디폴트 메소드를 활용하는 방법은 세가지가 있다.
1. 디폴트메소드를 단순히 상속만 받는다.
2. 디폴트메소드를 재정의해서 실행내용을 변경한다.
3. 디폴트메소드를 추상메소드로 재선언한다.
