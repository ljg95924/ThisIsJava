중첩클래스와 중첩인터페이스
 클래스중 여러 클래스와 관계를 맺는 경우가 아닌 특정클래스와만 관계를 맺는 클래스일 경우 관계 클래스를 클래스 내부에 선언하는 것이 좋다.
 중첩클래스란 클래스 내부에 선언한 클래스를 말하는데 중첩클래스를 사용하면 두 클래스의 멤버들을 서로 쉽게 접근할 수 있으며
 외부에는 불필요한 관계 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다.
 인터페이스도 클래스 내부에 선언할 수 있다. 내부에 선언하는 이유는 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위함.
 중첩 인터페이스는 주로 UI프로그래밍에서 이벤트를 처리할 목적으로 많이 활용된다.

중첩 클래스는 클래스 내부에 선언되는 위치에 따라서 두가지로 분류된다.
1. 멤버 클래스: 클래스의 멤버로서 선언되는 중첩 클래스, 클래스나 객체가 사용중이라면 언제든지 재사용가능
 1) 인스턴스 멤버클래스: A 객체를 생성해야만 사용할 수 있는 B 중첩 클래스
  class A{
   class B{}
  }
  인스턴스 멤버 클래스는 인스턴스 필드와 메소드만 선언이 가능하고 정적 필드와 메소드는 선언할 수 없다.
  A 클래스 외부에서 인스턴스 멤버 클래스 B의 객체를 생성하려면 먼저 A 객체를 생성하고 B 객체를 생성해야 한다.
  A a = new A();
  A.B b = a.new B();

 2) 정적 멤버 클래스: A 클래스로 바로 접근할 수 있는 B 중첩 클래스
  class A{
   static class B{}
  }
  정적 멤버 클래스는 모든 종류의 필드와 메소드를 선언할 수 있다.
  A 클래스 외부에서 정적 멤버 클래스 B의 객체를 생성하기 위해서는 A 객체를 생성할 필요가 없다.
  A.B b = new A.B();
  b.method1(); (인스턴스 필드, 메소드 사용시)
  A.B.method2(); (정적 필드, 메소드 사용시)

2. 로컬 클래스: 메소드 내부에서 선언되는 중첩 클래스, 메소드 실행 시에만 사용되고 메소드 실행 종료시 없어짐
 method()가 실행할때만 사용할 수 있는 B 중첩 클래스
 class A{
  void method(){
   class B{}
  }
 }
 로컬 클래스는 접근제한자(public, private) 및 static 을 붙일 수 없다. 로컬 클래스는 메소드 내부에서만 사용되므로 접근을 제한할 필요가 없다
 로컬 클래스 내부에는 인스턴스 필드와 메소드만 선언이 가능하고 정작 필드와 메소드는 선언할 수 없다.
 주로 비동기 처리를 위해 스레드 객체를 만들때 사용한다.

중첩 클래스의 접근 제한
 1) 바깥 필드와 메소드에서 사용 제한
 멤버 클래스가 인스턴스 또는 정적으로 선엄됨에 따라 바깥 클래스의 필드와 메소드에 사용 제한이 생긴다.
 인스턴스로 선언된 클래스의 경우 바깥 클래스에서 정적 필드의 초기값이나 정적 메소드에서는 객체를 생성할 수 없다.
 반면 정적 멤버 클래스는 바깥 클래스에서 모든 필드의 초기값이나 모든 메소드에서 객체를 생성할 수 있다.

 2) 멤버 클래스에서 사용 제한
 멤버 클래스가 인스턴스 또는 정작으로 선언됨에 따라 멤버 클래스 내부에서 바깥 클래스의 필드와 메소드를 접근할 때에도 제한이 따른다.
 인스턴스 멤버 클래스 안에서는 바깥 클래스의 모든 필드와 모든 메소드에 접근할 수 있지만
 정적 멤버 클래스 안에서는 바깥 클래스의 정작 필드와 정적 메소드에만 접근할 수 있다.

 3) 로컬 클래스에서 사용 제한
 로컬 클래스 내부에서는 바깥 클래스의 필드나 메소드를 제한 없이 사용할 수 있다.
 문제는 메소드의 매개변수나 로컬변수를 로컬 클래스에서 사용할 때이다.
 로컬 클래스의 객체는 메소드 실행이 끝나도 힙 메모리에 존재해서 계속 사용될 수 있다.
 매개변수나 로컬변수는 메소드 실행이 끝나면 스택메모리에서 사리지기 때문에 로컬객체에서 사용할 경우 문제가 발생한다.
 자바는 이 문제를 해결하기 위해 컴파일 시 로컬 클래스에서 사용하는 매개변수나 로컬변수의 기억장소를 로컬클래스 내부에 복사해 두고 사용한다.
 그리고 매개변수나 로컬변수가 수정되어 기억장소가 변경되면 로컬클래스에 복사해 둔 기억장소와 달라지는 문제를 해결하기 위해
 매개변수나 로컬변수를 final로 선언해서 수정을 막는다.
 자바8부터는 final을 선언하지 않아도 final의 특성을 갖는다.
 변수를 선언할때 final 키워드의 유무는 로컬클래스의 복사위치이지만 신경쓰지말고
 로컬 클래스에서 사용된 매개변수와 로컬변수는 모두 final 특성을 갖는다는것만 알면된다!!

중첩클래스에서 바깥클래스 참조얻기
 클래스 내부에서 this는 객체 자신의 참조이다. 중첩 클래스에서 this키워드를 사용하면
 바깥클래스의 객체 참조가 아니라 중첩클래스의 객체 참조가 된다.
 따라서 중첩클래스 내부에서 this.필드, this.메소드()로 호출하면 중첩클래스의 필드와 메소드가 사용된다.
 중첩클래스내부에서 바깥클래스의 객체참조를 얻으려면 바깥클래스의이름을 this앞에 붙여주면 된다.
 바깥클래스.this.필드(또는 메소드());

중첩 인터페이스
 클래스의 멤버로 선언된 인터페이스를 말하는데 인터페이스를 클래스 내부에 선언하는 이유는
 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위해서이다. 특히 UI프로그래밍에서 이벤트를 처리할 목적으로 활용됨

익명객체
 익명객체는 이름이 없는 객체를 말한다. 익명객체는 단독으로 생성할 수 없고 클래스를 상속하거나 인터페이스를 구현해야만 생성할 수 있다.
 익명객체는 필드의 초기값이나 로컬변수의 초기값, 매개변수의 매개값으로 주로 대입된다.
 UI이벤트 처리객체나 스레드 객체를 간편하게 생성할 목적으로 익명객체가 많이 활용된다.

 익명 자식객체 생성
  부모 타입으로 필드나 변수를 선언하고 자식 객체를 초기값으로 대입하는경우.
  부모클래스를 상속해서 자식클래스를 선언하고 new 연산자를 이용하여 자식객체를 생성한 후 필드나 로컬변수에 대입하는것이 기본이다.
  그러나 자식클래스가 재사용되지않고 오로지 해당 필드와변수의 초기값으로만 사용할 경우라면
  익명자식객체를 생성해서 초기값으로 대입하는것이 좋은 방법이다.
  익명자식객체를 생성하는방법은
  부모클래스 변수 = new 부모클래스(매개값){
   필드, 메소드
  };
  부모클래스(매개값){}은 부모클래스를 상속해서 중괄호{}와 같이 자식 클래스를 선언하라는 뜻이고,
  new 연산자는 이렇게 선언된 자식 클래스를 객체로 생성한다.
  부모클래스(매개값)은 부모생성자를 호출하는 코드로 매개값은 부모 생성자에 맞게 입력하면된다.
  중괄호{}내부에는 필드나 메소드를 선언하거나 부모클래스의 메소드를 재정의하는 내용이 온다.
  일반클래스와 차이점은 생성자를 선언할 수 없다는 것이다.

  익명 자식객체에 새롭게! 정의된 필드와 메소드는 익명 자식객체 내부에서만 사용되고, 외부에서는 필드와 메소드에 접근할 수 없다.
  왜냐하면 익명 자식객체는 부모타입변수에 대입되므로 부모타입에 선언된 것만 사용할 수 있다.

 익명 구현객체 생성
  인터페이스 타입으로 필드나 변수를 선언하고 구현객체를 초기값으로 대입하는 경우
  구현 클래스를 선언하고 new 연산자를 이용해서 구현객체를 생성한 후 필드나 로컬변수에 대입하는것이 기본이다.
  그러나 구현클래스가 재사용되지않고 오로지 해당 필드와 변수의 초기값으로만 사용하는 경우라면 익명구현객체를 초기값으로 대입하는 것이 좋다.
  인터페이스 [필드|변수] = new 인터페이스() {
    //인터페이스에 선언된 추상메소드의 실체메소드 선언
    //필드, 메소드
  }
  인터페이스(){} 는 인터페이스를 구현해서 중괄호{}와 같이 클래스를 선언하라는 뜻이고, new 연산자는 이렇게 선언된 클래스를 객체로 생성한다.
  {}에는 인터페이스에 선언된 모든 추상메소드의 실체메소드를 작성해야한다. 추가적으로 필드와 메소드를 선언할 수 있지만
  실체메소드에서만 사용이 가능하고 외부에서는 사용하지 못한다.